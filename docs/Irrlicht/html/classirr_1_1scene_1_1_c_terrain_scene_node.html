<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Irrlicht: irr::scene::CTerrainSceneNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Irrlicht
   &#160;<span id="projectnumber">v1.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classirr_1_1scene_1_1_c_terrain_scene_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classirr_1_1scene_1_1_c_terrain_scene_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::scene::CTerrainSceneNode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A scene node for displaying terrain using the geo mip map algorithm.  
 <a href="classirr_1_1scene_1_1_c_terrain_scene_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_terrain_scene_node_8h_source.html">CTerrainSceneNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for irr::scene::CTerrainSceneNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1scene_1_1_c_terrain_scene_node.png" usemap="#irr::scene::CTerrainSceneNode_map" alt=""/>
  <map id="irr::scene::CTerrainSceneNode_map" name="irr::scene::CTerrainSceneNode_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf0c2423999b9658f9ad1e3bba086720"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#abf0c2423999b9658f9ad1e3bba086720">CTerrainSceneNode</a> (ISceneNode *parent, ISceneManager *mgr, io::IFileSystem *fs, s32 id, s32 maxLOD=4, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="memdesc:abf0c2423999b9658f9ad1e3bba086720"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="#abf0c2423999b9658f9ad1e3bba086720">More...</a><br/></td></tr>
<tr class="separator:abf0c2423999b9658f9ad1e3bba086720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d97bfc9ff0cf8201bc1121d1172d7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0d97bfc9ff0cf8201bc1121d1172d7b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#ac0d97bfc9ff0cf8201bc1121d1172d7b">~CTerrainSceneNode</a> ()</td></tr>
<tr class="memdesc:ac0d97bfc9ff0cf8201bc1121d1172d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br/></td></tr>
<tr class="separator:ac0d97bfc9ff0cf8201bc1121d1172d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3734e983126fd07beb8e769589162c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3734e983126fd07beb8e769589162c2"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#ae3734e983126fd07beb8e769589162c2">loadHeightMap</a> (io::IReadFile *file, video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 smoothFactor=0)</td></tr>
<tr class="memdesc:ae3734e983126fd07beb8e769589162c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the terrain data. Loads the vertices from the heightMapFile. <br/></td></tr>
<tr class="separator:ae3734e983126fd07beb8e769589162c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05faa690ac383a121808e926bbd24a1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05faa690ac383a121808e926bbd24a1f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a05faa690ac383a121808e926bbd24a1f">loadHeightMapRAW</a> (io::IReadFile *file, s32 bitsPerPixel=16, bool signedData=true, bool floatVals=false, s32 width=0, video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 smoothFactor=0)</td></tr>
<tr class="memdesc:a05faa690ac383a121808e926bbd24a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the terrain data. Loads the vertices from the heightMapFile. <br/></td></tr>
<tr class="separator:a05faa690ac383a121808e926bbd24a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2cd795bd791d460df82f065304c6fc"><td class="memItemLeft" align="right" valign="top">virtual video::SMaterial &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aac2cd795bd791d460df82f065304c6fc">getMaterial</a> (u32 i)</td></tr>
<tr class="memdesc:aac2cd795bd791d460df82f065304c6fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the material based on the zero based index i.  <a href="#aac2cd795bd791d460df82f065304c6fc">More...</a><br/></td></tr>
<tr class="separator:aac2cd795bd791d460df82f065304c6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e48b82cf8acff480287d65807bf13d"><td class="memItemLeft" align="right" valign="top">virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a71e48b82cf8acff480287d65807bf13d">getMaterialCount</a> () const </td></tr>
<tr class="memdesc:a71e48b82cf8acff480287d65807bf13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of materials used by this scene node ( always 1 )  <a href="#a71e48b82cf8acff480287d65807bf13d">More...</a><br/></td></tr>
<tr class="separator:a71e48b82cf8acff480287d65807bf13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b77af71ad0e9b35ca21f167a7e9e27"><td class="memItemLeft" align="right" valign="top">virtual const core::vector3df &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a17b77af71ad0e9b35ca21f167a7e9e27">getScale</a> () const </td></tr>
<tr class="separator:a17b77af71ad0e9b35ca21f167a7e9e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7017656346664116a78f207acb21c1b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a7017656346664116a78f207acb21c1b9">setScale</a> (const core::vector3df &amp;scale)</td></tr>
<tr class="separator:a7017656346664116a78f207acb21c1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199ac8ad782803c658401141e8b9d420"><td class="memItemLeft" align="right" valign="top">virtual const core::vector3df &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a199ac8ad782803c658401141e8b9d420">getRotation</a> () const </td></tr>
<tr class="separator:a199ac8ad782803c658401141e8b9d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8017fda081bc31eec1c810c4c7f796"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#afb8017fda081bc31eec1c810c4c7f796">setRotation</a> (const core::vector3df &amp;rotation)</td></tr>
<tr class="separator:afb8017fda081bc31eec1c810c4c7f796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746868fc885ea23e38784ce8a2740489"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a746868fc885ea23e38784ce8a2740489">setRotationPivot</a> (const core::vector3df &amp;pivot)</td></tr>
<tr class="separator:a746868fc885ea23e38784ce8a2740489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa67deffa97589163afa11d75faec35"><td class="memItemLeft" align="right" valign="top">virtual const core::vector3df &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aeaa67deffa97589163afa11d75faec35">getPosition</a> () const </td></tr>
<tr class="separator:aeaa67deffa97589163afa11d75faec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6d8f5609b98e9f269ccffd74178d75"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aeb6d8f5609b98e9f269ccffd74178d75">setPosition</a> (const core::vector3df &amp;newpos)</td></tr>
<tr class="separator:aeb6d8f5609b98e9f269ccffd74178d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf84ba8a40e35d94f7137a68c1acb9fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#acf84ba8a40e35d94f7137a68c1acb9fb">OnRegisterSceneNode</a> ()</td></tr>
<tr class="separator:acf84ba8a40e35d94f7137a68c1acb9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae80a172a06889273adadd13b6aa64ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae80a172a06889273adadd13b6aa64ad"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aae80a172a06889273adadd13b6aa64ad">render</a> ()</td></tr>
<tr class="memdesc:aae80a172a06889273adadd13b6aa64ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render the scene node. <br/></td></tr>
<tr class="separator:aae80a172a06889273adadd13b6aa64ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1338c7c5102594673fc837f7554bd79a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1338c7c5102594673fc837f7554bd79a"></a>
virtual const core::aabbox3d<br class="typebreak"/>
&lt; f32 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a1338c7c5102594673fc837f7554bd79a">getBoundingBox</a> () const </td></tr>
<tr class="memdesc:a1338c7c5102594673fc837f7554bd79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box of the entire terrain. <br/></td></tr>
<tr class="separator:a1338c7c5102594673fc837f7554bd79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16df767d60ef3979421d854938feef42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16df767d60ef3979421d854938feef42"></a>
virtual const core::aabbox3d<br class="typebreak"/>
&lt; f32 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a16df767d60ef3979421d854938feef42">getBoundingBox</a> (s32 patchX, s32 patchZ) const </td></tr>
<tr class="memdesc:a16df767d60ef3979421d854938feef42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box of a patch. <br/></td></tr>
<tr class="separator:a16df767d60ef3979421d854938feef42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89a205b4f80037970c260f1f90885b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af89a205b4f80037970c260f1f90885b7"></a>
virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#af89a205b4f80037970c260f1f90885b7">getIndexCount</a> () const </td></tr>
<tr class="memdesc:af89a205b4f80037970c260f1f90885b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of indices currently used to draw the scene node. <br/></td></tr>
<tr class="separator:af89a205b4f80037970c260f1f90885b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c9c429ca8ede2921d58dde1686094a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99c9c429ca8ede2921d58dde1686094a"></a>
virtual IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a99c9c429ca8ede2921d58dde1686094a">getMesh</a> ()</td></tr>
<tr class="memdesc:a99c9c429ca8ede2921d58dde1686094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mesh. <br/></td></tr>
<tr class="separator:a99c9c429ca8ede2921d58dde1686094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b649a7eec9d5cd9b84449858ab25fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78b649a7eec9d5cd9b84449858ab25fb"></a>
virtual IMeshBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a78b649a7eec9d5cd9b84449858ab25fb">getRenderBuffer</a> ()</td></tr>
<tr class="memdesc:a78b649a7eec9d5cd9b84449858ab25fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the buffer used by the terrain (most users will not need this) <br/></td></tr>
<tr class="separator:a78b649a7eec9d5cd9b84449858ab25fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2867dd7ecb1150d4ccc8598542e59126"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a2867dd7ecb1150d4ccc8598542e59126">getMeshBufferForLOD</a> (IDynamicMeshBuffer &amp;mb, s32 LOD=0) const </td></tr>
<tr class="separator:a2867dd7ecb1150d4ccc8598542e59126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51de8d7ff1cfe4cf4d0dd288ab50c14c"><td class="memItemLeft" align="right" valign="top">virtual s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a51de8d7ff1cfe4cf4d0dd288ab50c14c">getIndicesForPatch</a> (core::array&lt; u32 &gt; &amp;indices, s32 patchX, s32 patchZ, s32 LOD=0)</td></tr>
<tr class="separator:a51de8d7ff1cfe4cf4d0dd288ab50c14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2832de1cc9bd349490473d151aea2c4"><td class="memItemLeft" align="right" valign="top">virtual s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aa2832de1cc9bd349490473d151aea2c4">getCurrentLODOfPatches</a> (core::array&lt; s32 &gt; &amp;LODs) const </td></tr>
<tr class="separator:aa2832de1cc9bd349490473d151aea2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fc289346513dfdaf17942e21ef967b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a71fc289346513dfdaf17942e21ef967b">setLODOfPatch</a> (s32 patchX, s32 patchZ, s32 LOD=0)</td></tr>
<tr class="separator:a71fc289346513dfdaf17942e21ef967b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19359cbd20636918ae7ed2be4c6e9ee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19359cbd20636918ae7ed2be4c6e9ee5"></a>
virtual const core::vector3df &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a19359cbd20636918ae7ed2be4c6e9ee5">getTerrainCenter</a> () const </td></tr>
<tr class="memdesc:a19359cbd20636918ae7ed2be4c6e9ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns center of terrain. <br/></td></tr>
<tr class="separator:a19359cbd20636918ae7ed2be4c6e9ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406b0b5c2acbd5c6048314345682a8b"><td class="memItemLeft" align="right" valign="top">virtual f32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#ab406b0b5c2acbd5c6048314345682a8b">getHeight</a> (f32 x, f32 y) const </td></tr>
<tr class="memdesc:ab406b0b5c2acbd5c6048314345682a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns center of terrain.  <a href="#ab406b0b5c2acbd5c6048314345682a8b">More...</a><br/></td></tr>
<tr class="separator:ab406b0b5c2acbd5c6048314345682a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa098919c643b088d6ff93c79fbd02b07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aa098919c643b088d6ff93c79fbd02b07">setCameraMovementDelta</a> (f32 delta)</td></tr>
<tr class="separator:aa098919c643b088d6ff93c79fbd02b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8b1191a069e7b085383be5a9aaf947"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a9a8b1191a069e7b085383be5a9aaf947">setCameraRotationDelta</a> (f32 delta)</td></tr>
<tr class="separator:a9a8b1191a069e7b085383be5a9aaf947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb114e9d0c2f48b31ca07d9cb57b7c60"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#acb114e9d0c2f48b31ca07d9cb57b7c60">setDynamicSelectorUpdate</a> (bool bVal)</td></tr>
<tr class="separator:acb114e9d0c2f48b31ca07d9cb57b7c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f41826b0842b235948e7155361edb8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#ae7f41826b0842b235948e7155361edb8">overrideLODDistance</a> (s32 LOD, f64 newDistance)</td></tr>
<tr class="separator:ae7f41826b0842b235948e7155361edb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab601dacdc758a052340fb2e2ecbdb256"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#ab601dacdc758a052340fb2e2ecbdb256">scaleTexture</a> (f32 scale=1.0f, f32 scale2=0.0f)</td></tr>
<tr class="memdesc:ab601dacdc758a052340fb2e2ecbdb256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales the two textures.  <a href="#ab601dacdc758a052340fb2e2ecbdb256">More...</a><br/></td></tr>
<tr class="separator:ab601dacdc758a052340fb2e2ecbdb256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f186786d3cb925d73c1ba474695012"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f186786d3cb925d73c1ba474695012"></a>
virtual ESCENE_NODE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a50f186786d3cb925d73c1ba474695012">getType</a> () const </td></tr>
<tr class="memdesc:a50f186786d3cb925d73c1ba474695012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of the scene node. <br/></td></tr>
<tr class="separator:a50f186786d3cb925d73c1ba474695012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf110dbd297b4b03ebe590d7c759ba66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf110dbd297b4b03ebe590d7c759ba66"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#aaf110dbd297b4b03ebe590d7c759ba66">serializeAttributes</a> (io::IAttributes *out, io::SAttributeReadWriteOptions *options=0) const </td></tr>
<tr class="memdesc:aaf110dbd297b4b03ebe590d7c759ba66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes attributes of the scene node. <br/></td></tr>
<tr class="separator:aaf110dbd297b4b03ebe590d7c759ba66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c618b04c915041172e69603d47a64f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2c618b04c915041172e69603d47a64f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#ac2c618b04c915041172e69603d47a64f">deserializeAttributes</a> (io::IAttributes *in, io::SAttributeReadWriteOptions *options=0)</td></tr>
<tr class="memdesc:ac2c618b04c915041172e69603d47a64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads attributes of the scene node. <br/></td></tr>
<tr class="separator:ac2c618b04c915041172e69603d47a64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b7ec2f16ce2c7141cd8d1513b1bec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21b7ec2f16ce2c7141cd8d1513b1bec5"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html#a21b7ec2f16ce2c7141cd8d1513b1bec5">clone</a> (ISceneNode *newParent, ISceneManager *newManager)</td></tr>
<tr class="memdesc:a21b7ec2f16ce2c7141cd8d1513b1bec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of this scene node and its children. <br/></td></tr>
<tr class="separator:a21b7ec2f16ce2c7141cd8d1513b1bec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3593e8e73b51f0d6b9848814f7b602f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3593e8e73b51f0d6b9848814f7b602f5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CTerrainTriangleSelector</b></td></tr>
<tr class="separator:a3593e8e73b51f0d6b9848814f7b602f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A scene node for displaying terrain using the geo mip map algorithm. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abf0c2423999b9658f9ad1e3bba086720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">irr::scene::CTerrainSceneNode::CTerrainSceneNode </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneManager *&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">io::IFileSystem *&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>maxLOD</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E_TERRAIN_PATCH_SIZE&#160;</td>
          <td class="paramname"><em>patchSize</em> = <code>ETPS_17</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0.0f,&#160;0.0f,&#160;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>core::vector3df(0.0f,&#160;0.0f,&#160;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1.0f,&#160;1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor </p>
<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent,:</td><td>The node which this node is a child of. Making this node a child of another node, or making it a parent of another node is yet untested and most likely does not work properly. </td></tr>
    <tr><td class="paramname">mgr,:</td><td>Pointer to the scene manager. </td></tr>
    <tr><td class="paramname">id,:</td><td>The id of the node </td></tr>
    <tr><td class="paramname">maxLOD,:</td><td>The maximum LOD ( Level of Detail ) for the node. </td></tr>
    <tr><td class="paramname">patchSize,:</td><td>An E_GEOMIPMAP_PATCH_SIZE enumeration defining the size of each patch of the terrain. </td></tr>
    <tr><td class="paramname">position,:</td><td>The absolute position of this node. </td></tr>
    <tr><td class="paramname">rotation,:</td><td>The absolute rotation of this node. ( NOT YET IMPLEMENTED ) </td></tr>
    <tr><td class="paramname">scale,:</td><td>The scale factor for the terrain. If you're using a heightmap of size 128x128 and would like your terrain to be 12800x12800 in game units, then use a scale factor of ( core::vector ( 100.0f, 100.0f, 100.0f ). If you use a Y scaling factor of 0.0f, then your terrain will be flat. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa2832de1cc9bd349490473d151aea2c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">s32 irr::scene::CTerrainSceneNode::getCurrentLODOfPatches </td>
          <td>(</td>
          <td class="paramtype">core::array&lt; s32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>LODs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Populates an array with the CurrentLOD of each patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LODs,:</td><td>A reference to a core::array&lt;s32&gt; to hold the values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of elements in the array </dd></dl>

</div>
</div>
<a class="anchor" id="ab406b0b5c2acbd5c6048314345682a8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">f32 irr::scene::CTerrainSceneNode::getHeight </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns center of terrain. </p>
<p>Gets the height. </p>

</div>
</div>
<a class="anchor" id="a51de8d7ff1cfe4cf4d0dd288ab50c14c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">s32 irr::scene::CTerrainSceneNode::getIndicesForPatch </td>
          <td>(</td>
          <td class="paramtype">core::array&lt; u32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>patchX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>patchZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>LOD</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the indices for a specified patch at a specified Level of Detail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices,:</td><td>A reference to an array of u32 indices. </td></tr>
    <tr><td class="paramname">patchX,:</td><td>Patch x coordinate. </td></tr>
    <tr><td class="paramname">patchZ,:</td><td>Patch z coordinate. </td></tr>
    <tr><td class="paramname">LOD,:</td><td>The level of detail to get for that patch. If -1, then get the CurrentLOD. If the CurrentLOD is set to -1, meaning it's not shown, then it will retrieve the triangles at the highest LOD (0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: Number of indices put into the buffer.</dd></dl>
<p>Gets the indices for a specified patch at a specified Level of Detail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb,:</td><td>A reference to an array of u32 indices. </td></tr>
    <tr><td class="paramname">patchX,:</td><td>Patch x coordinate. </td></tr>
    <tr><td class="paramname">patchZ,:</td><td>Patch z coordinate. </td></tr>
    <tr><td class="paramname">LOD,:</td><td>The level of detail to get for that patch. If -1, then get the CurrentLOD. If the CurrentLOD is set to -1, meaning it's not shown, then it will retrieve the triangles at the highest LOD (0). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: Number if indices put into the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="aac2cd795bd791d460df82f065304c6fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">video::SMaterial &amp; irr::scene::CTerrainSceneNode::getMaterial </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the material based on the zero based index i. </p>
<p>Returns the material based on the zero based index i. This scene node only uses 1 material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i,:</td><td>Zero based index i. UNUSED, left in for virtual purposes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the single material this scene node uses. </dd></dl>

</div>
</div>
<a class="anchor" id="a71e48b82cf8acff480287d65807bf13d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">u32 irr::scene::CTerrainSceneNode::getMaterialCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns amount of materials used by this scene node ( always 1 ) </p>
<p>Returns amount of materials used by this scene node ( always 1 ) </p>
<dl class="section return"><dt>Returns</dt><dd>Returns current count of materials used by this scene node ( always 1 ) </dd></dl>

</div>
</div>
<a class="anchor" id="a2867dd7ecb1150d4ccc8598542e59126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::getMeshBufferForLOD </td>
          <td>(</td>
          <td class="paramtype">IDynamicMeshBuffer &amp;&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>LOD</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the meshbuffer data based on a specified Level of Detail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb,:</td><td>A reference to an IDynamicMeshBuffer object </td></tr>
    <tr><td class="paramname">LOD,:</td><td>The Level Of Detail you want the indices from.</td></tr>
  </table>
  </dd>
</dl>
<p>Gets the meshbuffer data based on a specified Level of Detail. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mb,:</td><td>A reference to an SMeshBuffer object </td></tr>
    <tr><td class="paramname">LOD,:</td><td>The Level Of Detail you want the indices from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaa67deffa97589163afa11d75faec35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const core::vector3df&amp; irr::scene::CTerrainSceneNode::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the last positioning vector applied to the scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the last position vector applied to the scene node. </dd></dl>

</div>
</div>
<a class="anchor" id="a199ac8ad782803c658401141e8b9d420"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const core::vector3df&amp; irr::scene::CTerrainSceneNode::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the last rotation factor applied to the scene node. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the last rotation factor applied to the scene node. </dd></dl>

</div>
</div>
<a class="anchor" id="a17b77af71ad0e9b35ca21f167a7e9e27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const core::vector3df&amp; irr::scene::CTerrainSceneNode::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the last scaling factor applied to the scene node. This value only represents the last scaling factor presented to the node. For instance, if you make create the node with a scale factor of ( 1.0f, 1.0f, 1.0f ) then call setScale ( 50.0f, 5.0f, 50.0f ), then make another call to setScale with the values ( 2.0f, 2.0f, 2.0f ), this will return core::vector3df ( 2.0f, 2.0f, 2.0f ), although the total scaling of the scene node is core::vector3df ( 100.0f, 10.0f, 100.0f ). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the last scaling factor passed to the scene node. </dd></dl>

</div>
</div>
<a class="anchor" id="acf84ba8a40e35d94f7137a68c1acb9fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::OnRegisterSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the scene nodes indices if the camera has moved or rotated by a certain threshold, which can be changed using the SetCameraMovementDeltaThreshold and SetCameraRotationDeltaThreshold functions. This also determines if a given patch for the scene node is within the view frustum and if it's not the indices are not generated for that patch. </p>

</div>
</div>
<a class="anchor" id="ae7f41826b0842b235948e7155361edb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::CTerrainSceneNode::overrideLODDistance </td>
          <td>(</td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>LOD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f64&#160;</td>
          <td class="paramname"><em>newDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override the default generation of distance thresholds for determining the LOD a patch is rendered at. If any LOD is overridden, then the scene node will no longer apply scaling factors to these values. If you override these distances and then apply a scale to the scene node, it is your responsibility to update the new distances to work best with your new terrain size.</p>
<p>Override the default generation of distance thresholds for determining the LOD a patch is rendered at. </p>

</div>
</div>
<a class="anchor" id="ab601dacdc758a052340fb2e2ecbdb256"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::scaleTexture </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>resolution2</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales the two textures. </p>
<p>Creates a planar texture mapping on the terrain </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution,:</td><td>resolution of the planar mapping. This is the value specifying the relation between world space and texture coordinate space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa098919c643b088d6ff93c79fbd02b07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::CTerrainSceneNode::setCameraMovementDelta </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the movement camera threshold which is used to determine when to recalculate indices for the scene node. The default value is 10.0f. </p>

</div>
</div>
<a class="anchor" id="a9a8b1191a069e7b085383be5a9aaf947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::CTerrainSceneNode::setCameraRotationDelta </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the rotation camera threshold which is used to determine when to recalculate indices for the scene node. The default value is 1.0f. </p>

</div>
</div>
<a class="anchor" id="acb114e9d0c2f48b31ca07d9cb57b7c60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::CTerrainSceneNode::setDynamicSelectorUpdate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether or not the node should dynamically update it its associated selector when the geomipmap data changes. param bVal: Boolean value representing whether or not to update selector dynamically. NOTE: Temporarily disabled while working out issues with DynamicSelectorUpdate </p>

</div>
</div>
<a class="anchor" id="a71fc289346513dfdaf17942e21ef967b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::setLODOfPatch </td>
          <td>(</td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>patchX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>patchZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>LOD</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Manually sets the LOD of a patch </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patchX,:</td><td>Patch x coordinate. </td></tr>
    <tr><td class="paramname">patchZ,:</td><td>Patch z coordinate. </td></tr>
    <tr><td class="paramname">LOD,:</td><td>The level of detail to set the patch to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb6d8f5609b98e9f269ccffd74178d75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::setPosition </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>newpos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Moves the scene nodes vertices by the vector specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpos,:</td><td>Vector specifying how much to move each vertex of the scene node.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the position of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpos,:</td><td>New postition of the scene node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb8017fda081bc31eec1c810c4c7f796"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::setRotation </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rotates the node. This only modifies the relative rotation of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation,:</td><td>New rotation of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the rotation of the node. This only modifies the relative rotation of the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation,:</td><td>New rotation of the node in degrees. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a746868fc885ea23e38784ce8a2740489"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::setRotationPivot </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>pivot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the pivot point for rotation of this node. NOTE: The default for the RotationPivot will be the center of the individual tile.</p>
<p>Sets the pivot point for rotation of this node. This is useful for the TiledTerrainManager to rotate all terrain tiles around a global world point. NOTE: The default for the RotationPivot will be the center of the individual tile. </p>

</div>
</div>
<a class="anchor" id="a7017656346664116a78f207acb21c1b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CTerrainSceneNode::setScale </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scales the scene nodes vertices by the vector specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale,:</td><td>Scaling factor to apply to the node.</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the scale of the scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale,:</td><td>New scale of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Ben/Documents/Visual Studio 2010/Projects/PSI/source/Irrlicht/<a class="el" href="_c_terrain_scene_node_8h_source.html">CTerrainSceneNode.h</a></li>
<li>C:/Users/Ben/Documents/Visual Studio 2010/Projects/PSI/source/Irrlicht/CTerrainSceneNode.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>irr</b></li><li class="navelem"><b>scene</b></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1_c_terrain_scene_node.html">CTerrainSceneNode</a></li>
    <li class="footer">Generated on Wed Mar 20 2013 15:24:58 for Irrlicht by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
