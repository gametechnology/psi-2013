<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Irrlicht: irr::scene::CSceneManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Irrlicht
   &#160;<span id="projectnumber">v1.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classirr_1_1scene_1_1_c_scene_manager.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1scene_1_1_c_scene_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::scene::CSceneManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_scene_manager_8h_source.html">CSceneManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for irr::scene::CSceneManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1scene_1_1_c_scene_manager.png" usemap="#irr::scene::CSceneManager_map" alt=""/>
  <map id="irr::scene::CSceneManager_map" name="irr::scene::CSceneManager_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed9a65def23a33a76228c37474d5ffdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed9a65def23a33a76228c37474d5ffdd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aed9a65def23a33a76228c37474d5ffdd">CSceneManager</a> (video::IVideoDriver *driver, io::IFileSystem *fs, gui::ICursorControl *cursorControl, IMeshCache *cache=0, gui::IGUIEnvironment *guiEnvironment=0)</td></tr>
<tr class="memdesc:aed9a65def23a33a76228c37474d5ffdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor <br/></td></tr>
<tr class="separator:aed9a65def23a33a76228c37474d5ffdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e0be5012f1b923d7879f6a26f8bc5b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ad0e0be5012f1b923d7879f6a26f8bc5b">~CSceneManager</a> ()</td></tr>
<tr class="memdesc:ad0e0be5012f1b923d7879f6a26f8bc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#ad0e0be5012f1b923d7879f6a26f8bc5b">More...</a><br/></td></tr>
<tr class="separator:ad0e0be5012f1b923d7879f6a26f8bc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357ecf36c404f8fe8d2a39b1e3ed9e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a357ecf36c404f8fe8d2a39b1e3ed9e6d"></a>
virtual IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a357ecf36c404f8fe8d2a39b1e3ed9e6d">getMesh</a> (const io::path &amp;filename)</td></tr>
<tr class="memdesc:a357ecf36c404f8fe8d2a39b1e3ed9e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets an animateable mesh. loads it if needed. returned pointer must not be dropped. <br/></td></tr>
<tr class="separator:a357ecf36c404f8fe8d2a39b1e3ed9e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423d718f359a90d8a7887577a8a4b42d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a423d718f359a90d8a7887577a8a4b42d"></a>
virtual IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a423d718f359a90d8a7887577a8a4b42d">getMesh</a> (io::IReadFile *file)</td></tr>
<tr class="memdesc:a423d718f359a90d8a7887577a8a4b42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets an animateable mesh. loads it if needed. returned pointer must not be dropped. <br/></td></tr>
<tr class="separator:a423d718f359a90d8a7887577a8a4b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34553414d755a09fae9a2eccf5e15290"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34553414d755a09fae9a2eccf5e15290"></a>
virtual IMeshCache *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a34553414d755a09fae9a2eccf5e15290">getMeshCache</a> ()</td></tr>
<tr class="memdesc:a34553414d755a09fae9a2eccf5e15290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interface to the mesh cache which is shared beween all existing scene managers. <br/></td></tr>
<tr class="separator:a34553414d755a09fae9a2eccf5e15290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d746f68500c4aa2c5bd77ac2ae438a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d746f68500c4aa2c5bd77ac2ae438a9"></a>
virtual video::IVideoDriver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a2d746f68500c4aa2c5bd77ac2ae438a9">getVideoDriver</a> ()</td></tr>
<tr class="memdesc:a2d746f68500c4aa2c5bd77ac2ae438a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the video driver <br/></td></tr>
<tr class="separator:a2d746f68500c4aa2c5bd77ac2ae438a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279172e9c8035c9130525d1cf616cd6b"><td class="memItemLeft" align="right" valign="top">virtual gui::IGUIEnvironment *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a279172e9c8035c9130525d1cf616cd6b">getGUIEnvironment</a> ()</td></tr>
<tr class="memdesc:a279172e9c8035c9130525d1cf616cd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the gui environment  <a href="#a279172e9c8035c9130525d1cf616cd6b">More...</a><br/></td></tr>
<tr class="separator:a279172e9c8035c9130525d1cf616cd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a90a12f000d4caf2ca512a73a6bd47d"><td class="memItemLeft" align="right" valign="top">virtual io::IFileSystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a6a90a12f000d4caf2ca512a73a6bd47d">getFileSystem</a> ()</td></tr>
<tr class="memdesc:a6a90a12f000d4caf2ca512a73a6bd47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the filesystem  <a href="#a6a90a12f000d4caf2ca512a73a6bd47d">More...</a><br/></td></tr>
<tr class="separator:a6a90a12f000d4caf2ca512a73a6bd47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d98342a07da1787595bf4a98f20342"><td class="memItemLeft" align="right" valign="top">virtual IVolumeLightSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#af7d98342a07da1787595bf4a98f20342">addVolumeLightSceneNode</a> (ISceneNode *parent=0, s32 id=-1, const u32 subdivU=32, const u32 subdivV=32, const video::SColor foot=video::SColor(51, 0, 230, 180), const video::SColor tail=video::SColor(0, 0, 0, 0), const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="separator:af7d98342a07da1787595bf4a98f20342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a54d667205735a2d599ee3369860eb"><td class="memItemLeft" align="right" valign="top">virtual IMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ad7a54d667205735a2d599ee3369860eb">addCubeSceneNode</a> (f32 size=10.0f, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="separator:ad7a54d667205735a2d599ee3369860eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c023fa51f48e390bc36980f1d61f27"><td class="memItemLeft" align="right" valign="top">virtual IMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a54c023fa51f48e390bc36980f1d61f27">addSphereSceneNode</a> (f32 radius=5.0f, s32 polyCount=16, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="memdesc:a54c023fa51f48e390bc36980f1d61f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a sphere scene node to the scene.  <a href="#a54c023fa51f48e390bc36980f1d61f27">More...</a><br/></td></tr>
<tr class="separator:a54c023fa51f48e390bc36980f1d61f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c6dd8b8bf67ccaa4107c1bc695cb91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58c6dd8b8bf67ccaa4107c1bc695cb91"></a>
virtual IAnimatedMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a58c6dd8b8bf67ccaa4107c1bc695cb91">addAnimatedMeshSceneNode</a> (IAnimatedMesh *mesh, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)</td></tr>
<tr class="memdesc:a58c6dd8b8bf67ccaa4107c1bc695cb91"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a scene node for rendering an animated mesh model <br/></td></tr>
<tr class="separator:a58c6dd8b8bf67ccaa4107c1bc695cb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473a4b8ba6737268c20ba9697e1051e"><td class="memItemLeft" align="right" valign="top">virtual IMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a6473a4b8ba6737268c20ba9697e1051e">addMeshSceneNode</a> (IMesh *mesh, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), bool alsoAddIfMeshPointerZero=false)</td></tr>
<tr class="separator:a6473a4b8ba6737268c20ba9697e1051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a0344616f452b8e6a521dc539629bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a0344616f452b8e6a521dc539629bd"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a59a0344616f452b8e6a521dc539629bd">addWaterSurfaceSceneNode</a> (IMesh *mesh, f32 waveHeight, f32 waveSpeed, f32 wlenght, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="memdesc:a59a0344616f452b8e6a521dc539629bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node for rendering a animated water surface mesh. <br/></td></tr>
<tr class="separator:a59a0344616f452b8e6a521dc539629bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb8f228d8047fc04837675e60916883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb8f228d8047fc04837675e60916883"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aebb8f228d8047fc04837675e60916883">render</a> ()</td></tr>
<tr class="memdesc:aebb8f228d8047fc04837675e60916883"><td class="mdescLeft">&#160;</td><td class="mdescRight">renders the node. <br/></td></tr>
<tr class="separator:aebb8f228d8047fc04837675e60916883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaad00ace504de61a8557102a4ff7a17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaad00ace504de61a8557102a4ff7a17"></a>
virtual const core::aabbox3d<br class="typebreak"/>
&lt; f32 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#afaad00ace504de61a8557102a4ff7a17">getBoundingBox</a> () const </td></tr>
<tr class="memdesc:afaad00ace504de61a8557102a4ff7a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the axis aligned bounding box of this node <br/></td></tr>
<tr class="separator:afaad00ace504de61a8557102a4ff7a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37f87a15dae0cc0916e8f6e023d8270"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae37f87a15dae0cc0916e8f6e023d8270"></a>
virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae37f87a15dae0cc0916e8f6e023d8270">registerNodeForRendering</a> (ISceneNode *node, E_SCENE_NODE_RENDER_PASS pass=ESNRP_AUTOMATIC)</td></tr>
<tr class="memdesc:ae37f87a15dae0cc0916e8f6e023d8270"><td class="mdescLeft">&#160;</td><td class="mdescRight">registers a node for rendering it at a specific time. <br/></td></tr>
<tr class="separator:ae37f87a15dae0cc0916e8f6e023d8270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af861474ffb96b9d4d2d9a6d6303cdb6a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#af861474ffb96b9d4d2d9a6d6303cdb6a">drawAll</a> ()</td></tr>
<tr class="memdesc:af861474ffb96b9d4d2d9a6d6303cdb6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">draws all scene nodes  <a href="#af861474ffb96b9d4d2d9a6d6303cdb6a">More...</a><br/></td></tr>
<tr class="separator:af861474ffb96b9d4d2d9a6d6303cdb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3be92a6e7aefe7a9a6e8948232affa2"><td class="memItemLeft" align="right" valign="top">virtual IMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aa3be92a6e7aefe7a9a6e8948232affa2">addOctreeSceneNode</a> (IAnimatedMesh *mesh, ISceneNode *parent=0, s32 id=-1, s32 minimalPolysPerNode=512, bool alsoAddIfMeshPointerZero=false)</td></tr>
<tr class="separator:aa3be92a6e7aefe7a9a6e8948232affa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5f2d928b78ff4465b7b786f8f44797"><td class="memItemLeft" align="right" valign="top">virtual IMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a9d5f2d928b78ff4465b7b786f8f44797">addOctreeSceneNode</a> (IMesh *mesh, ISceneNode *parent=0, s32 id=-1, s32 minimalPolysPerNode=128, bool alsoAddIfMeshPointerZero=false)</td></tr>
<tr class="separator:a9d5f2d928b78ff4465b7b786f8f44797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c93fe59faade8c2719c0dbac1a1f859"><td class="memItemLeft" align="right" valign="top">virtual ICameraSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a0c93fe59faade8c2719c0dbac1a1f859">addCameraSceneNode</a> (ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;lookat=core::vector3df(0, 0, 100), s32 id=-1, bool makeActive=true)</td></tr>
<tr class="separator:a0c93fe59faade8c2719c0dbac1a1f859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca015ff12264168f9f6ef51dc0508d8"><td class="memItemLeft" align="right" valign="top">virtual ICameraSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#afca015ff12264168f9f6ef51dc0508d8">addCameraSceneNodeMaya</a> (ISceneNode *parent=0, f32 rotateSpeed=-1500.f, f32 zoomSpeed=200.f, f32 translationSpeed=1500.f, s32 id=-1, f32 distance=70.f, bool makeActive=true)</td></tr>
<tr class="separator:afca015ff12264168f9f6ef51dc0508d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf42fc8078c742d34b800fa9a032cd"><td class="memItemLeft" align="right" valign="top">virtual ICameraSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#acaaf42fc8078c742d34b800fa9a032cd">addCameraSceneNodeFPS</a> (ISceneNode *parent=0, f32 rotateSpeed=100.0f, f32 moveSpeed=.5f, s32 id=-1, SKeyMap *keyMapArray=0, s32 keyMapSize=0, bool noVerticalMovement=false, f32 jumpSpeed=0.f, bool invertMouseY=false, bool makeActive=true)</td></tr>
<tr class="separator:acaaf42fc8078c742d34b800fa9a032cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eb844548c09912553ef857f96380a0"><td class="memItemLeft" align="right" valign="top">virtual ILightSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ad9eb844548c09912553ef857f96380a0">addLightSceneNode</a> (ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), video::SColorf color=video::SColorf(1.0f, 1.0f, 1.0f), f32 range=100.0f, s32 id=-1)</td></tr>
<tr class="separator:ad9eb844548c09912553ef857f96380a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee31671738bcf2e93146b1c6ccd9023"><td class="memItemLeft" align="right" valign="top">virtual IBillboardSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#adee31671738bcf2e93146b1c6ccd9023">addBillboardSceneNode</a> (ISceneNode *parent=0, const core::dimension2d&lt; f32 &gt; &amp;size=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor shadeTop=0xFFFFFFFF, video::SColor shadeBottom=0xFFFFFFFF)</td></tr>
<tr class="separator:adee31671738bcf2e93146b1c6ccd9023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b8cd28f5dc81b3518f4249fa1187f4"><td class="memItemLeft" align="right" valign="top">virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a51b8cd28f5dc81b3518f4249fa1187f4">addSkyBoxSceneNode</a> (video::ITexture *top, video::ITexture *bottom, video::ITexture *left, video::ITexture *right, video::ITexture *front, video::ITexture *back, ISceneNode *parent=0, s32 id=-1)</td></tr>
<tr class="separator:a51b8cd28f5dc81b3518f4249fa1187f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61889c3eca09fa0cb70b3c9f8a25e92"><td class="memItemLeft" align="right" valign="top">virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ab61889c3eca09fa0cb70b3c9f8a25e92">addSkyDomeSceneNode</a> (video::ITexture *texture, u32 horiRes=16, u32 vertRes=8, f32 texturePercentage=0.9, f32 spherePercentage=2.0, f32 radius=1000.f, ISceneNode *parent=0, s32 id=-1)</td></tr>
<tr class="separator:ab61889c3eca09fa0cb70b3c9f8a25e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9de85adb1c71933ba521daebe3b12be"><td class="memItemLeft" align="right" valign="top">virtual ITextSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae9de85adb1c71933ba521daebe3b12be">addTextSceneNode</a> (gui::IGUIFont *font, const wchar_t *text, video::SColor color=video::SColor(100, 255, 255, 255), ISceneNode *parent=0, const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1)</td></tr>
<tr class="separator:ae9de85adb1c71933ba521daebe3b12be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a6479253c81daf2f7f7376863f2515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a6479253c81daf2f7f7376863f2515"></a>
virtual IBillboardTextSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a36a6479253c81daf2f7f7376863f2515">addBillboardTextSceneNode</a> (gui::IGUIFont *font, const wchar_t *text, ISceneNode *parent=0, const core::dimension2d&lt; f32 &gt; &amp;size=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), const core::vector3df &amp;position=core::vector3df(0, 0, 0), s32 id=-1, video::SColor colorTop=0xFFFFFFFF, video::SColor colorBottom=0xFFFFFFFF)</td></tr>
<tr class="memdesc:a36a6479253c81daf2f7f7376863f2515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a text scene node, which uses billboards. <br/></td></tr>
<tr class="separator:a36a6479253c81daf2f7f7376863f2515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ff3e15b7a4fa1fcc468ed66a736177"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05ff3e15b7a4fa1fcc468ed66a736177"></a>
virtual IMeshSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a05ff3e15b7a4fa1fcc468ed66a736177">addQuake3SceneNode</a> (const IMeshBuffer *meshBuffer, const quake3::IShader *shader, ISceneNode *parent=0, s32 id=-1)</td></tr>
<tr class="memdesc:a05ff3e15b7a4fa1fcc468ed66a736177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node, which can render a quake3 shader. <br/></td></tr>
<tr class="separator:a05ff3e15b7a4fa1fcc468ed66a736177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c30d9eb68c40524c7c13f03278609f"><td class="memItemLeft" align="right" valign="top">virtual IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a49c30d9eb68c40524c7c13f03278609f">addHillPlaneMesh</a> (const io::path &amp;name, const core::dimension2d&lt; f32 &gt; &amp;tileSize, const core::dimension2d&lt; u32 &gt; &amp;tileCount, video::SMaterial *material=0, f32 hillHeight=0.0f, const core::dimension2d&lt; f32 &gt; &amp;countHills=core::dimension2d&lt; f32 &gt;(1.0f, 1.0f), const core::dimension2d&lt; f32 &gt; &amp;textureRepeatCount=core::dimension2d&lt; f32 &gt;(1.0f, 1.0f))</td></tr>
<tr class="separator:a49c30d9eb68c40524c7c13f03278609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a65ea2326687e47e47232fbe345774a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a65ea2326687e47e47232fbe345774a"></a>
virtual IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a6a65ea2326687e47e47232fbe345774a">addTerrainMesh</a> (const io::path &amp;meshname, video::IImage *texture, video::IImage *heightmap, const core::dimension2d&lt; f32 &gt; &amp;stretchSize=core::dimension2d&lt; f32 &gt;(10.0f, 10.0f), f32 maxHeight=200.0f, const core::dimension2d&lt; u32 &gt; &amp;defaultVertexBlockSize=core::dimension2d&lt; u32 &gt;(64, 64))</td></tr>
<tr class="memdesc:a6a65ea2326687e47e47232fbe345774a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a terrain mesh to the mesh pool. <br/></td></tr>
<tr class="separator:a6a65ea2326687e47e47232fbe345774a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c62ca2c69728f79c0d3f80110f7a67"><td class="memItemLeft" align="right" valign="top">virtual IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a80c62ca2c69728f79c0d3f80110f7a67">addArrowMesh</a> (const io::path &amp;name, video::SColor vtxColor0, video::SColor vtxColor1, u32 tesselationCylinder, u32 tesselationCone, f32 height, f32 cylinderHeight, f32 width0, f32 width1)</td></tr>
<tr class="memdesc:a80c62ca2c69728f79c0d3f80110f7a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a arrow mesh to the mesh pool.  <a href="#a80c62ca2c69728f79c0d3f80110f7a67">More...</a><br/></td></tr>
<tr class="separator:a80c62ca2c69728f79c0d3f80110f7a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91ac3065d6884cc94047df93841367a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa91ac3065d6884cc94047df93841367a"></a>
IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aa91ac3065d6884cc94047df93841367a">addSphereMesh</a> (const io::path &amp;name, f32 radius=5.f, u32 polyCountX=16, u32 polyCountY=16)</td></tr>
<tr class="memdesc:aa91ac3065d6884cc94047df93841367a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a static sphere mesh to the mesh pool. <br/></td></tr>
<tr class="separator:aa91ac3065d6884cc94047df93841367a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d9482aea5ec04df3a68d8a2d3d9c67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1d9482aea5ec04df3a68d8a2d3d9c67"></a>
IAnimatedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#af1d9482aea5ec04df3a68d8a2d3d9c67">addVolumeLightMesh</a> (const io::path &amp;name, const u32 SubdivideU=32, const u32 SubdivideV=32, const video::SColor FootColor=video::SColor(51, 0, 230, 180), const video::SColor TailColor=video::SColor(0, 0, 0, 0))</td></tr>
<tr class="memdesc:af1d9482aea5ec04df3a68d8a2d3d9c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a static volume light mesh to the mesh pool. <br/></td></tr>
<tr class="separator:af1d9482aea5ec04df3a68d8a2d3d9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c08fafeabd4fa0b178ddce25e2f8ba7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c08fafeabd4fa0b178ddce25e2f8ba7"></a>
virtual IParticleSystemSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a7c08fafeabd4fa0b178ddce25e2f8ba7">addParticleSystemSceneNode</a> (bool withDefaultEmitter=true, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0, 0, 0), const core::vector3df &amp;rotation=core::vector3df(0, 0, 0), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f))</td></tr>
<tr class="memdesc:a7c08fafeabd4fa0b178ddce25e2f8ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particle system scene node. <br/></td></tr>
<tr class="separator:a7c08fafeabd4fa0b178ddce25e2f8ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13537c0fb00f9f34ed8cb407392d6735"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13537c0fb00f9f34ed8cb407392d6735"></a>
virtual ITerrainSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a13537c0fb00f9f34ed8cb407392d6735">addTerrainSceneNode</a> (const io::path &amp;heightMapFileName, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=4, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0, bool addAlsoIfHeightmapEmpty=false)</td></tr>
<tr class="memdesc:a13537c0fb00f9f34ed8cb407392d6735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a terrain scene node to the scene graph. <br/></td></tr>
<tr class="separator:a13537c0fb00f9f34ed8cb407392d6735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982d65c64cca5df23d0f90b0f64ef66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7982d65c64cca5df23d0f90b0f64ef66"></a>
virtual ITerrainSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a7982d65c64cca5df23d0f90b0f64ef66">addTerrainSceneNode</a> (io::IReadFile *heightMap, ISceneNode *parent=0, s32 id=-1, const core::vector3df &amp;position=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;rotation=core::vector3df(0.0f, 0.0f, 0.0f), const core::vector3df &amp;scale=core::vector3df(1.0f, 1.0f, 1.0f), video::SColor vertexColor=video::SColor(255, 255, 255, 255), s32 maxLOD=4, E_TERRAIN_PATCH_SIZE patchSize=ETPS_17, s32 smoothFactor=0, bool addAlsoIfHeightmapEmpty=false)</td></tr>
<tr class="memdesc:a7982d65c64cca5df23d0f90b0f64ef66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a terrain scene node to the scene graph. <br/></td></tr>
<tr class="separator:a7982d65c64cca5df23d0f90b0f64ef66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea274d7dd629d094d04029de18008b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ea274d7dd629d094d04029de18008b7"></a>
virtual <br class="typebreak"/>
IDummyTransformationSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a3ea274d7dd629d094d04029de18008b7">addDummyTransformationSceneNode</a> (ISceneNode *parent=0, s32 id=-1)</td></tr>
<tr class="memdesc:a3ea274d7dd629d094d04029de18008b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dummy transformation scene node to the scene graph. <br/></td></tr>
<tr class="separator:a3ea274d7dd629d094d04029de18008b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84356c50fa9bf92ff94c08b80431835a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84356c50fa9bf92ff94c08b80431835a"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a84356c50fa9bf92ff94c08b80431835a">addEmptySceneNode</a> (ISceneNode *parent, s32 id=-1)</td></tr>
<tr class="memdesc:a84356c50fa9bf92ff94c08b80431835a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an empty scene node. <br/></td></tr>
<tr class="separator:a84356c50fa9bf92ff94c08b80431835a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8872a7d44b695f0115afc518d1778d"><td class="memItemLeft" align="right" valign="top">virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#acb8872a7d44b695f0115afc518d1778d">getRootSceneNode</a> ()</td></tr>
<tr class="separator:acb8872a7d44b695f0115afc518d1778d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b85191fa5bd908a1c2474bf440f49f1"><td class="memItemLeft" align="right" valign="top">virtual ICameraSceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a5b85191fa5bd908a1c2474bf440f49f1">getActiveCamera</a> () const </td></tr>
<tr class="separator:a5b85191fa5bd908a1c2474bf440f49f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a28d4630075ef900d9cc0eb40ba9ba4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a8a28d4630075ef900d9cc0eb40ba9ba4">setActiveCamera</a> (ICameraSceneNode *camera)</td></tr>
<tr class="separator:a8a28d4630075ef900d9cc0eb40ba9ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8020dde9333353f6bc7b6b9eb77e94"><td class="memItemLeft" align="right" valign="top">virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a4d8020dde9333353f6bc7b6b9eb77e94">createRotationAnimator</a> (const core::vector3df &amp;rotationPerSecond)</td></tr>
<tr class="memdesc:a4d8020dde9333353f6bc7b6b9eb77e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a rotation animator, which rotates the attached scene node around itself.  <a href="#a4d8020dde9333353f6bc7b6b9eb77e94">More...</a><br/></td></tr>
<tr class="separator:a4d8020dde9333353f6bc7b6b9eb77e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d316866dc59dd0e29e185bc4e0f78fd"><td class="memItemLeft" align="right" valign="top">virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a2d316866dc59dd0e29e185bc4e0f78fd">createFlyCircleAnimator</a> (const core::vector3df &amp;center=core::vector3df(0.f, 0.f, 0.f), f32 radius=100.f, f32 speed=0.001f, const core::vector3df &amp;direction=core::vector3df(0.f, 1.f, 0.f), f32 startPosition=0.f, f32 radiusEllipsoid=0.f)</td></tr>
<tr class="memdesc:a2d316866dc59dd0e29e185bc4e0f78fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a fly circle animator  <a href="#a2d316866dc59dd0e29e185bc4e0f78fd">More...</a><br/></td></tr>
<tr class="separator:a2d316866dc59dd0e29e185bc4e0f78fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244c8ef1830bec752f357ece18ee4173"><td class="memItemLeft" align="right" valign="top">virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a244c8ef1830bec752f357ece18ee4173">createFlyStraightAnimator</a> (const core::vector3df &amp;startPoint, const core::vector3df &amp;endPoint, u32 timeForWay, bool loop=false, bool pingpong=false)</td></tr>
<tr class="separator:a244c8ef1830bec752f357ece18ee4173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14319a725b000a5c19b3e07e19eb2898"><td class="memItemLeft" align="right" valign="top">virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a14319a725b000a5c19b3e07e19eb2898">createTextureAnimator</a> (const core::array&lt; video::ITexture * &gt; &amp;textures, s32 timePerFrame, bool loop)</td></tr>
<tr class="separator:a14319a725b000a5c19b3e07e19eb2898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb106b4a6f0a9ff8d73be64972ffd5ba"><td class="memItemLeft" align="right" valign="top">virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#abb106b4a6f0a9ff8d73be64972ffd5ba">createDeleteAnimator</a> (u32 timeMS)</td></tr>
<tr class="separator:abb106b4a6f0a9ff8d73be64972ffd5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21d47b1d04e0a364799ecdfeacb1d2b"><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
ISceneNodeAnimatorCollisionResponse *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae21d47b1d04e0a364799ecdfeacb1d2b">createCollisionResponseAnimator</a> (ITriangleSelector *world, ISceneNode *sceneNode, const core::vector3df &amp;ellipsoidRadius=core::vector3df(30, 60, 30), const core::vector3df &amp;gravityPerSecond=core::vector3df(0,-1.0f, 0), const core::vector3df &amp;ellipsoidTranslation=core::vector3df(0, 0, 0), f32 slidingValue=0.0005f)</td></tr>
<tr class="separator:ae21d47b1d04e0a364799ecdfeacb1d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b181a88d51de97025eec4274a9c8d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4b181a88d51de97025eec4274a9c8d2"></a>
virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae4b181a88d51de97025eec4274a9c8d2">createFollowSplineAnimator</a> (s32 startTime, const core::array&lt; core::vector3df &gt; &amp;points, f32 speed, f32 tightness, bool loop, bool pingpong)</td></tr>
<tr class="memdesc:ae4b181a88d51de97025eec4274a9c8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a follow spline animator. <br/></td></tr>
<tr class="separator:ae4b181a88d51de97025eec4274a9c8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d80cdc75776b924584d7f41af4a3f1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d80cdc75776b924584d7f41af4a3f1c"></a>
virtual ITriangleSelector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1d80cdc75776b924584d7f41af4a3f1c">createTriangleSelector</a> (IMesh *mesh, ISceneNode *node)</td></tr>
<tr class="memdesc:a1d80cdc75776b924584d7f41af4a3f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple ITriangleSelector, based on a mesh. <br/></td></tr>
<tr class="separator:a1d80cdc75776b924584d7f41af4a3f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90637f2287c1e4d6167b6d638a17d5ca"><td class="memItemLeft" align="right" valign="top">virtual ITriangleSelector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a90637f2287c1e4d6167b6d638a17d5ca">createTriangleSelector</a> (IAnimatedMeshSceneNode *node)</td></tr>
<tr class="separator:a90637f2287c1e4d6167b6d638a17d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9ff1d31e29c3762077845b9575eafb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c9ff1d31e29c3762077845b9575eafb"></a>
virtual ITriangleSelector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1c9ff1d31e29c3762077845b9575eafb">createOctreeTriangleSelector</a> (IMesh *mesh, ISceneNode *node, s32 minimalPolysPerNode)</td></tr>
<tr class="memdesc:a1c9ff1d31e29c3762077845b9575eafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple ITriangleSelector, based on a mesh. <br/></td></tr>
<tr class="separator:a1c9ff1d31e29c3762077845b9575eafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e4fdafec6a433c58e3a2a1319fec41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e4fdafec6a433c58e3a2a1319fec41"></a>
virtual ITriangleSelector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a05e4fdafec6a433c58e3a2a1319fec41">createTriangleSelectorFromBoundingBox</a> (ISceneNode *node)</td></tr>
<tr class="memdesc:a05e4fdafec6a433c58e3a2a1319fec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple dynamic ITriangleSelector, based on a axis aligned bounding box. <br/></td></tr>
<tr class="separator:a05e4fdafec6a433c58e3a2a1319fec41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e05cbd557f77fdca8167f00cb5453f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7e05cbd557f77fdca8167f00cb5453f"></a>
virtual IMetaTriangleSelector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ab7e05cbd557f77fdca8167f00cb5453f">createMetaTriangleSelector</a> ()</td></tr>
<tr class="memdesc:ab7e05cbd557f77fdca8167f00cb5453f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a meta triangle selector. <br/></td></tr>
<tr class="separator:ab7e05cbd557f77fdca8167f00cb5453f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42dea70677b1745e23afe10a20bf00db"><td class="memItemLeft" align="right" valign="top">virtual ITriangleSelector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a42dea70677b1745e23afe10a20bf00db">createTerrainTriangleSelector</a> (ITerrainSceneNode *node, s32 LOD=0)</td></tr>
<tr class="memdesc:a42dea70677b1745e23afe10a20bf00db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a triangle selector which can select triangles from a terrain scene node.  <a href="#a42dea70677b1745e23afe10a20bf00db">More...</a><br/></td></tr>
<tr class="separator:a42dea70677b1745e23afe10a20bf00db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab901dd33ba08bdbccc3852ff564c62df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab901dd33ba08bdbccc3852ff564c62df"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ab901dd33ba08bdbccc3852ff564c62df">addExternalMeshLoader</a> (IMeshLoader *externalLoader)</td></tr>
<tr class="memdesc:ab901dd33ba08bdbccc3852ff564c62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external mesh loader. <br/></td></tr>
<tr class="separator:ab901dd33ba08bdbccc3852ff564c62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692823bf5b62174b215fde2993f650fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a692823bf5b62174b215fde2993f650fb"></a>
virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a692823bf5b62174b215fde2993f650fb">getMeshLoaderCount</a> () const </td></tr>
<tr class="memdesc:a692823bf5b62174b215fde2993f650fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mesh loaders supported by Irrlicht at this time. <br/></td></tr>
<tr class="separator:a692823bf5b62174b215fde2993f650fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fad87c2e454234eec7469f2e9095791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fad87c2e454234eec7469f2e9095791"></a>
virtual IMeshLoader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1fad87c2e454234eec7469f2e9095791">getMeshLoader</a> (u32 index) const </td></tr>
<tr class="memdesc:a1fad87c2e454234eec7469f2e9095791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given mesh loader. <br/></td></tr>
<tr class="separator:a1fad87c2e454234eec7469f2e9095791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16030e393c5bedaa24e2e1684476ce3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae16030e393c5bedaa24e2e1684476ce3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae16030e393c5bedaa24e2e1684476ce3">addExternalSceneLoader</a> (ISceneLoader *externalLoader)</td></tr>
<tr class="memdesc:ae16030e393c5bedaa24e2e1684476ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external scene loader. <br/></td></tr>
<tr class="separator:ae16030e393c5bedaa24e2e1684476ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26bb986e97ceef455243546d1630c5"><td class="memItemLeft" align="right" valign="top">virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1a26bb986e97ceef455243546d1630c5">getSceneLoaderCount</a> () const </td></tr>
<tr class="memdesc:a1a26bb986e97ceef455243546d1630c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of scene loaders supported by Irrlicht at this time.  <a href="#a1a26bb986e97ceef455243546d1630c5">More...</a><br/></td></tr>
<tr class="separator:a1a26bb986e97ceef455243546d1630c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1382a39355b0c5ebf90f3e6f413870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad1382a39355b0c5ebf90f3e6f413870"></a>
virtual ISceneLoader *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aad1382a39355b0c5ebf90f3e6f413870">getSceneLoader</a> (u32 index) const </td></tr>
<tr class="memdesc:aad1382a39355b0c5ebf90f3e6f413870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given scene loader. <br/></td></tr>
<tr class="separator:aad1382a39355b0c5ebf90f3e6f413870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d6ff3c718cc0cedef37a663cfc5d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d6ff3c718cc0cedef37a663cfc5d7f"></a>
virtual ISceneCollisionManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a42d6ff3c718cc0cedef37a663cfc5d7f">getSceneCollisionManager</a> ()</td></tr>
<tr class="memdesc:a42d6ff3c718cc0cedef37a663cfc5d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the scene collision manager. <br/></td></tr>
<tr class="separator:a42d6ff3c718cc0cedef37a663cfc5d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065e05b21c244d8ade0f009cd15d2710"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a065e05b21c244d8ade0f009cd15d2710"></a>
virtual IMeshManipulator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a065e05b21c244d8ade0f009cd15d2710">getMeshManipulator</a> ()</td></tr>
<tr class="memdesc:a065e05b21c244d8ade0f009cd15d2710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the mesh manipulator. <br/></td></tr>
<tr class="separator:a065e05b21c244d8ade0f009cd15d2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbaa0689b869b296e47f09315a1e5a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fbaa0689b869b296e47f09315a1e5a0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a5fbaa0689b869b296e47f09315a1e5a0">setShadowColor</a> (video::SColor color)</td></tr>
<tr class="memdesc:a5fbaa0689b869b296e47f09315a1e5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the color of stencil buffers shadows drawn by the scene manager. <br/></td></tr>
<tr class="separator:a5fbaa0689b869b296e47f09315a1e5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19cc0874c44ff6404d8ee5ffaaa3f51b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19cc0874c44ff6404d8ee5ffaaa3f51b"></a>
virtual video::SColor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a19cc0874c44ff6404d8ee5ffaaa3f51b">getShadowColor</a> () const </td></tr>
<tr class="memdesc:a19cc0874c44ff6404d8ee5ffaaa3f51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current color of shadows. <br/></td></tr>
<tr class="separator:a19cc0874c44ff6404d8ee5ffaaa3f51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb88416967e189c7f28daee000cdd5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb88416967e189c7f28daee000cdd5c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a3eb88416967e189c7f28daee000cdd5c">addToDeletionQueue</a> (ISceneNode *node)</td></tr>
<tr class="memdesc:a3eb88416967e189c7f28daee000cdd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node to the deletion queue. <br/></td></tr>
<tr class="separator:a3eb88416967e189c7f28daee000cdd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4dee53779b3de8c3f4323d3c687a56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4dee53779b3de8c3f4323d3c687a56"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a2e4dee53779b3de8c3f4323d3c687a56">getSceneNodeFromId</a> (s32 id, ISceneNode *start=0)</td></tr>
<tr class="memdesc:a2e4dee53779b3de8c3f4323d3c687a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first scene node with the specified id. <br/></td></tr>
<tr class="separator:a2e4dee53779b3de8c3f4323d3c687a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dc0e7cc05dc8dfc5f5df497f5cced8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33dc0e7cc05dc8dfc5f5df497f5cced8"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a33dc0e7cc05dc8dfc5f5df497f5cced8">getSceneNodeFromName</a> (const c8 *name, ISceneNode *start=0)</td></tr>
<tr class="memdesc:a33dc0e7cc05dc8dfc5f5df497f5cced8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first scene node with the specified name. <br/></td></tr>
<tr class="separator:a33dc0e7cc05dc8dfc5f5df497f5cced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e034dd5e949d3f03daa72eb24a8959"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e034dd5e949d3f03daa72eb24a8959"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#af4e034dd5e949d3f03daa72eb24a8959">getSceneNodeFromType</a> (scene::ESCENE_NODE_TYPE type, ISceneNode *start=0)</td></tr>
<tr class="memdesc:af4e034dd5e949d3f03daa72eb24a8959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first scene node with the specified type. <br/></td></tr>
<tr class="separator:af4e034dd5e949d3f03daa72eb24a8959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac107a2562f8fba7c50073a5194caef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac107a2562f8fba7c50073a5194caef2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aac107a2562f8fba7c50073a5194caef2">getSceneNodesFromType</a> (ESCENE_NODE_TYPE type, core::array&lt; scene::ISceneNode * &gt; &amp;outNodes, ISceneNode *start=0)</td></tr>
<tr class="memdesc:aac107a2562f8fba7c50073a5194caef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns scene nodes by type. <br/></td></tr>
<tr class="separator:aac107a2562f8fba7c50073a5194caef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1702d5a194a210f7c36e808593e43ceb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1702d5a194a210f7c36e808593e43ceb">postEventFromUser</a> (const SEvent &amp;event)</td></tr>
<tr class="separator:a1702d5a194a210f7c36e808593e43ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cb1944118f2030140069a67d2897a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0cb1944118f2030140069a67d2897a7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae0cb1944118f2030140069a67d2897a7">clear</a> ()</td></tr>
<tr class="memdesc:ae0cb1944118f2030140069a67d2897a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the whole scene. All scene nodes are removed. <br/></td></tr>
<tr class="separator:ae0cb1944118f2030140069a67d2897a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e779510944f3cd128d4dee71714fc51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e779510944f3cd128d4dee71714fc51"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1e779510944f3cd128d4dee71714fc51">removeAll</a> ()</td></tr>
<tr class="memdesc:a1e779510944f3cd128d4dee71714fc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children of this scene node. <br/></td></tr>
<tr class="separator:a1e779510944f3cd128d4dee71714fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793b237d2c9146ad9b960cac20e891f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793b237d2c9146ad9b960cac20e891f2"></a>
virtual io::IAttributes *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a793b237d2c9146ad9b960cac20e891f2">getParameters</a> ()</td></tr>
<tr class="memdesc:a793b237d2c9146ad9b960cac20e891f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns interface to the parameters set in this scene. <br/></td></tr>
<tr class="separator:a793b237d2c9146ad9b960cac20e891f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b19cd9536adadf1868ed70edc1a1922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b19cd9536adadf1868ed70edc1a1922"></a>
virtual E_SCENE_NODE_RENDER_PASS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a1b19cd9536adadf1868ed70edc1a1922">getSceneNodeRenderPass</a> () const </td></tr>
<tr class="memdesc:a1b19cd9536adadf1868ed70edc1a1922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current render pass. <br/></td></tr>
<tr class="separator:a1b19cd9536adadf1868ed70edc1a1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973340ede72e07d571793fe3af40d342"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a973340ede72e07d571793fe3af40d342"></a>
virtual ISceneManager *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a973340ede72e07d571793fe3af40d342">createNewSceneManager</a> (bool cloneContent)</td></tr>
<tr class="memdesc:a973340ede72e07d571793fe3af40d342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new scene manager. <br/></td></tr>
<tr class="separator:a973340ede72e07d571793fe3af40d342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac61e8384dd984b8b68db3ca7da0c9df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac61e8384dd984b8b68db3ca7da0c9df"></a>
virtual ESCENE_NODE_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aac61e8384dd984b8b68db3ca7da0c9df">getType</a> () const </td></tr>
<tr class="memdesc:aac61e8384dd984b8b68db3ca7da0c9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type of the scene node. <br/></td></tr>
<tr class="separator:aac61e8384dd984b8b68db3ca7da0c9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e52b0ea9d00c78d24443d5eff4f599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e52b0ea9d00c78d24443d5eff4f599"></a>
virtual ISceneNodeFactory *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a29e52b0ea9d00c78d24443d5eff4f599">getDefaultSceneNodeFactory</a> ()</td></tr>
<tr class="memdesc:a29e52b0ea9d00c78d24443d5eff4f599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default scene node factory which can create all built in scene nodes. <br/></td></tr>
<tr class="separator:a29e52b0ea9d00c78d24443d5eff4f599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e04c241d92ec1efc20386b47f77f5cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a2e04c241d92ec1efc20386b47f77f5cc">registerSceneNodeFactory</a> (ISceneNodeFactory *factoryToAdd)</td></tr>
<tr class="memdesc:a2e04c241d92ec1efc20386b47f77f5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node factory to the scene manager.  <a href="#a2e04c241d92ec1efc20386b47f77f5cc">More...</a><br/></td></tr>
<tr class="separator:a2e04c241d92ec1efc20386b47f77f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203d9023ca96c760d65214bb4a6a022e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a203d9023ca96c760d65214bb4a6a022e"></a>
virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a203d9023ca96c760d65214bb4a6a022e">getRegisteredSceneNodeFactoryCount</a> () const </td></tr>
<tr class="memdesc:a203d9023ca96c760d65214bb4a6a022e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of registered scene node factories. <br/></td></tr>
<tr class="separator:a203d9023ca96c760d65214bb4a6a022e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbd5e8f80253feccd9d949bf29f7981"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cbd5e8f80253feccd9d949bf29f7981"></a>
virtual ISceneNodeFactory *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a3cbd5e8f80253feccd9d949bf29f7981">getSceneNodeFactory</a> (u32 index)</td></tr>
<tr class="memdesc:a3cbd5e8f80253feccd9d949bf29f7981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scene node factory by index. <br/></td></tr>
<tr class="separator:a3cbd5e8f80253feccd9d949bf29f7981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ed5e70210d2861a56b941170f9011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121ed5e70210d2861a56b941170f9011"></a>
virtual const c8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a121ed5e70210d2861a56b941170f9011">getSceneNodeTypeName</a> (ESCENE_NODE_TYPE type)</td></tr>
<tr class="memdesc:a121ed5e70210d2861a56b941170f9011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typename from a scene node type or null if not found. <br/></td></tr>
<tr class="separator:a121ed5e70210d2861a56b941170f9011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf075f8278a07a80a241295faff41f15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf075f8278a07a80a241295faff41f15"></a>
virtual const c8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#adf075f8278a07a80a241295faff41f15">getAnimatorTypeName</a> (ESCENE_NODE_ANIMATOR_TYPE type)</td></tr>
<tr class="memdesc:adf075f8278a07a80a241295faff41f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a typename from a scene node animator type or null if not found. <br/></td></tr>
<tr class="separator:adf075f8278a07a80a241295faff41f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4763e84a7a7390326b16d8374dabf7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b4763e84a7a7390326b16d8374dabf7"></a>
virtual ISceneNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a6b4763e84a7a7390326b16d8374dabf7">addSceneNode</a> (const char *sceneNodeTypeName, ISceneNode *parent=0)</td></tr>
<tr class="memdesc:a6b4763e84a7a7390326b16d8374dabf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node to the scene by name. <br/></td></tr>
<tr class="separator:a6b4763e84a7a7390326b16d8374dabf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7851ed5053cb35e80a7c8ed264f38ad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7851ed5053cb35e80a7c8ed264f38ad7"></a>
virtual ISceneNodeAnimator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a7851ed5053cb35e80a7c8ed264f38ad7">createSceneNodeAnimator</a> (const char *typeName, ISceneNode *target=0)</td></tr>
<tr class="memdesc:a7851ed5053cb35e80a7c8ed264f38ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a scene node animator based on its type name <br/></td></tr>
<tr class="separator:a7851ed5053cb35e80a7c8ed264f38ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986ba72b82f39be28adcfa1f0097bf59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a986ba72b82f39be28adcfa1f0097bf59"></a>
virtual ISceneNodeAnimatorFactory *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a986ba72b82f39be28adcfa1f0097bf59">getDefaultSceneNodeAnimatorFactory</a> ()</td></tr>
<tr class="memdesc:a986ba72b82f39be28adcfa1f0097bf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default scene node animator factory which can create all built-in scene node animators. <br/></td></tr>
<tr class="separator:a986ba72b82f39be28adcfa1f0097bf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae655cbcd0d85cc1a6c03278f6e2c4153"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae655cbcd0d85cc1a6c03278f6e2c4153"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae655cbcd0d85cc1a6c03278f6e2c4153">registerSceneNodeAnimatorFactory</a> (ISceneNodeAnimatorFactory *factoryToAdd)</td></tr>
<tr class="memdesc:ae655cbcd0d85cc1a6c03278f6e2c4153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node animator factory to the scene manager. <br/></td></tr>
<tr class="separator:ae655cbcd0d85cc1a6c03278f6e2c4153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28a405f5944b96c19b5ca8c61fbdf15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad28a405f5944b96c19b5ca8c61fbdf15"></a>
virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ad28a405f5944b96c19b5ca8c61fbdf15">getRegisteredSceneNodeAnimatorFactoryCount</a> () const </td></tr>
<tr class="memdesc:ad28a405f5944b96c19b5ca8c61fbdf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns amount of registered scene node animator factories. <br/></td></tr>
<tr class="separator:ad28a405f5944b96c19b5ca8c61fbdf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d20367310b5182750a2035d13ce03e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82d20367310b5182750a2035d13ce03e"></a>
virtual ISceneNodeAnimatorFactory *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a82d20367310b5182750a2035d13ce03e">getSceneNodeAnimatorFactory</a> (u32 index)</td></tr>
<tr class="memdesc:a82d20367310b5182750a2035d13ce03e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a scene node animator factory by index. <br/></td></tr>
<tr class="separator:a82d20367310b5182750a2035d13ce03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17da0640769c7dca94535d8d4a39d5e3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a17da0640769c7dca94535d8d4a39d5e3">saveScene</a> (const io::path &amp;filename, ISceneUserDataSerializer *userDataSerializer=0, ISceneNode *node=0)</td></tr>
<tr class="memdesc:a17da0640769c7dca94535d8d4a39d5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current scene into a file.  <a href="#a17da0640769c7dca94535d8d4a39d5e3">More...</a><br/></td></tr>
<tr class="separator:a17da0640769c7dca94535d8d4a39d5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8156c6f906a470775ae0c57f48fc29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e8156c6f906a470775ae0c57f48fc29"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a8e8156c6f906a470775ae0c57f48fc29">saveScene</a> (io::IWriteFile *file, ISceneUserDataSerializer *userDataSerializer=0, ISceneNode *node=0)</td></tr>
<tr class="memdesc:a8e8156c6f906a470775ae0c57f48fc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current scene into a file. <br/></td></tr>
<tr class="separator:a8e8156c6f906a470775ae0c57f48fc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c20589110a6cadf43ee99083c69833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8c20589110a6cadf43ee99083c69833"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ab8c20589110a6cadf43ee99083c69833">saveScene</a> (io::IXMLWriter *writer, const io::path &amp;currentPath, ISceneUserDataSerializer *userDataSerializer=0, ISceneNode *node=0)</td></tr>
<tr class="memdesc:ab8c20589110a6cadf43ee99083c69833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the current scene into a file. <br/></td></tr>
<tr class="separator:ab8c20589110a6cadf43ee99083c69833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b1765239c02e9b934624a8ec30214c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a03b1765239c02e9b934624a8ec30214c">loadScene</a> (const io::path &amp;filename, ISceneUserDataSerializer *userDataSerializer=0, ISceneNode *rootNode=0)</td></tr>
<tr class="memdesc:a03b1765239c02e9b934624a8ec30214c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a scene. Note that the current scene is not cleared before.  <a href="#a03b1765239c02e9b934624a8ec30214c">More...</a><br/></td></tr>
<tr class="separator:a03b1765239c02e9b934624a8ec30214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbff7698c6d920e0d9c888e3aa0e787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dbff7698c6d920e0d9c888e3aa0e787"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a9dbff7698c6d920e0d9c888e3aa0e787">loadScene</a> (io::IReadFile *file, ISceneUserDataSerializer *userDataSerializer=0, ISceneNode *rootNode=0)</td></tr>
<tr class="memdesc:a9dbff7698c6d920e0d9c888e3aa0e787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a scene. Note that the current scene is not cleared before. <br/></td></tr>
<tr class="separator:a9dbff7698c6d920e0d9c888e3aa0e787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b883946d2db644b90ecf83d06918332"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b883946d2db644b90ecf83d06918332"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a7b883946d2db644b90ecf83d06918332">serializeAttributes</a> (io::IAttributes *out, io::SAttributeReadWriteOptions *options=0) const </td></tr>
<tr class="memdesc:a7b883946d2db644b90ecf83d06918332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes attributes of the scene node. <br/></td></tr>
<tr class="separator:a7b883946d2db644b90ecf83d06918332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdf857f083eea1bc5bea9f0504e18c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bdf857f083eea1bc5bea9f0504e18c9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a7bdf857f083eea1bc5bea9f0504e18c9">deserializeAttributes</a> (io::IAttributes *in, io::SAttributeReadWriteOptions *options=0)</td></tr>
<tr class="memdesc:a7bdf857f083eea1bc5bea9f0504e18c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads attributes of the scene node. <br/></td></tr>
<tr class="separator:a7bdf857f083eea1bc5bea9f0504e18c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d700e463282638e281e8a3cf7dd521"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2d700e463282638e281e8a3cf7dd521"></a>
virtual IMeshWriter *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aa2d700e463282638e281e8a3cf7dd521">createMeshWriter</a> (EMESH_WRITER_TYPE type)</td></tr>
<tr class="memdesc:aa2d700e463282638e281e8a3cf7dd521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mesh writer implementation if available. <br/></td></tr>
<tr class="separator:aa2d700e463282638e281e8a3cf7dd521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf93f9a55e6b25f87d6d649ac5277c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf93f9a55e6b25f87d6d649ac5277c1"></a>
virtual ISkinnedMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aebf93f9a55e6b25f87d6d649ac5277c1">createSkinnedMesh</a> ()</td></tr>
<tr class="memdesc:aebf93f9a55e6b25f87d6d649ac5277c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a skinned mesh, which is not available as header-only code. <br/></td></tr>
<tr class="separator:aebf93f9a55e6b25f87d6d649ac5277c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eb692e211d21ff104dc0f42c0cd6c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9eb692e211d21ff104dc0f42c0cd6c4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ac9eb692e211d21ff104dc0f42c0cd6c4">setAmbientLight</a> (const video::SColorf &amp;ambientColor)</td></tr>
<tr class="memdesc:ac9eb692e211d21ff104dc0f42c0cd6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ambient color of the scene. <br/></td></tr>
<tr class="separator:ac9eb692e211d21ff104dc0f42c0cd6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6616a815396418f296145253645e796"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6616a815396418f296145253645e796"></a>
virtual const video::SColorf &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ae6616a815396418f296145253645e796">getAmbientLight</a> () const </td></tr>
<tr class="memdesc:ae6616a815396418f296145253645e796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns ambient color of the scene. <br/></td></tr>
<tr class="separator:ae6616a815396418f296145253645e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab341febdc7b2f39a43ecd5e219c7ba24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab341febdc7b2f39a43ecd5e219c7ba24"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ab341febdc7b2f39a43ecd5e219c7ba24">setLightManager</a> (ILightManager *lightManager)</td></tr>
<tr class="memdesc:ab341febdc7b2f39a43ecd5e219c7ba24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a custom callbacks manager which gets callbacks during scene rendering. <br/></td></tr>
<tr class="separator:ab341febdc7b2f39a43ecd5e219c7ba24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa385076e969cdbbc6f569d500515696f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa385076e969cdbbc6f569d500515696f"></a>
virtual E_SCENE_NODE_RENDER_PASS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#aa385076e969cdbbc6f569d500515696f">getCurrentRendertime</a> () const </td></tr>
<tr class="memdesc:aa385076e969cdbbc6f569d500515696f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current render time. <br/></td></tr>
<tr class="separator:aa385076e969cdbbc6f569d500515696f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac284c2ffc268c8c73416e39a4d392f4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac284c2ffc268c8c73416e39a4d392f4b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#ac284c2ffc268c8c73416e39a4d392f4b">setCurrentRendertime</a> (E_SCENE_NODE_RENDER_PASS currentRendertime)</td></tr>
<tr class="memdesc:ac284c2ffc268c8c73416e39a4d392f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current render time. <br/></td></tr>
<tr class="separator:ac284c2ffc268c8c73416e39a4d392f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa88110c036134910b1ce38cdd9154a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaa88110c036134910b1ce38cdd9154a"></a>
virtual const IGeometryCreator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#abaa88110c036134910b1ce38cdd9154a">getGeometryCreator</a> (void) const </td></tr>
<tr class="memdesc:abaa88110c036134910b1ce38cdd9154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an instance of a geometry creator. <br/></td></tr>
<tr class="separator:abaa88110c036134910b1ce38cdd9154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb5f00898e5d62d9b4df34478a82c37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fb5f00898e5d62d9b4df34478a82c37"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html#a9fb5f00898e5d62d9b4df34478a82c37">isCulled</a> (const ISceneNode *node) const </td></tr>
<tr class="memdesc:a9fb5f00898e5d62d9b4df34478a82c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if node is culled <br/></td></tr>
<tr class="separator:a9fb5f00898e5d62d9b4df34478a82c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Scene Manager manages scene nodes, mesh recources, cameras and all the other stuff. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad0e0be5012f1b923d7879f6a26f8bc5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">irr::scene::CSceneManager::~CSceneManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>destructor </p>
<p>force to remove hardwareTextures from the driver because Scenes may hold internally data bounded to sceneNodes which may be destroyed twice </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a80c62ca2c69728f79c0d3f80110f7a67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IAnimatedMesh * irr::scene::CSceneManager::addArrowMesh </td>
          <td>(</td>
          <td class="paramtype">const io::path &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SColor&#160;</td>
          <td class="paramname"><em>vtxColor0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SColor&#160;</td>
          <td class="paramname"><em>vtxColor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>tesselationCylinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>tesselationCone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>cylinderHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>width0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>width1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a arrow mesh to the mesh pool. </p>
<p>Adds an arrow mesh to the mesh pool. </p>

</div>
</div>
<a class="anchor" id="adee31671738bcf2e93146b1c6ccd9023"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IBillboardSceneNode * irr::scene::CSceneManager::addBillboardSceneNode </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::dimension2d&lt; f32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em> = <code>core::dimension2d&lt;f32&gt;(10.0f,&#160;10.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SColor&#160;</td>
          <td class="paramname"><em>colorTop</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SColor&#160;</td>
          <td class="paramname"><em>colorBottom</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a billboard scene node to the scene. A billboard is like a 3d sprite: A 2d element, which always looks to the camera. It is usually used for things like explosions, fire, lensflares and things like that. </p>

</div>
</div>
<a class="anchor" id="a0c93fe59faade8c2719c0dbac1a1f859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICameraSceneNode * irr::scene::CSceneManager::addCameraSceneNode </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>lookat</em> = <code>core::vector3df(0,0,100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a camera scene node to the tree and sets it as active camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position,:</td><td>Position of the space relative to its parent where the camera will be placed. </td></tr>
    <tr><td class="paramname">lookat,:</td><td>Position where the camera will look at. Also known as target. </td></tr>
    <tr><td class="paramname">parent,:</td><td>Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to interface to camera</dd></dl>
<p>Adds a camera scene node to the tree and sets it as active camera. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position,:</td><td>Position of the space relative to its parent where the camera will be placed. </td></tr>
    <tr><td class="paramname">lookat,:</td><td>Position where the camera will look at. Also known as target. </td></tr>
    <tr><td class="paramname">parent,:</td><td>Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns pointer to interface to camera </dd></dl>

</div>
</div>
<a class="anchor" id="acaaf42fc8078c742d34b800fa9a032cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICameraSceneNode * irr::scene::CSceneManager::addCameraSceneNodeFPS </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>rotateSpeed</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>moveSpeed</em> = <code>.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SKeyMap *&#160;</td>
          <td class="paramname"><em>keyMapArray</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>keyMapSize</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noVerticalMovement</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>jumpSpeed</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertMouseY</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a camera scene node which is able to be controled with the mouse and keys like in most first person shooters (FPS):</p>
<p>Adds a camera scene node which is able to be controlled with the mouse and keys like in most first person shooters (FPS): </p>

</div>
</div>
<a class="anchor" id="afca015ff12264168f9f6ef51dc0508d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICameraSceneNode * irr::scene::CSceneManager::addCameraSceneNodeMaya </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>rotateSpeed</em> = <code>-1500.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>zoomSpeed</em> = <code>200.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>translationSpeed</em> = <code>1500.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>distance</em> = <code>70.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a camera scene node which is able to be controlle with the mouse similar like in the 3D Software Maya by Alias Wavefront. The returned pointer must not be dropped.</p>
<p>Adds a camera scene node which is able to be controlled with the mouse similar to in the 3D Software Maya by Alias Wavefront. The returned pointer must not be dropped. </p>

</div>
</div>
<a class="anchor" id="ad7a54d667205735a2d599ee3369860eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMeshSceneNode * irr::scene::CSceneManager::addCubeSceneNode </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>size</em> = <code>10.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1.0f,&#160;1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>adds a cube scene node to the scene. It is a simple cube of (1,1,1) size. the returned pointer must not be dropped.</p>
<p>adds a test scene node for test purposes to the scene. It is a simple cube of (1,1,1) size. the returned pointer must not be dropped. </p>

</div>
</div>
<a class="anchor" id="a49c30d9eb68c40524c7c13f03278609f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IAnimatedMesh * irr::scene::CSceneManager::addHillPlaneMesh </td>
          <td>(</td>
          <td class="paramtype">const io::path &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::dimension2d&lt; f32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tileSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::dimension2d&lt; u32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tileCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SMaterial *&#160;</td>
          <td class="paramname"><em>material</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>hillHeight</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::dimension2d&lt; f32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>countHills</em> = <code>core::dimension2d&lt;f32&gt;(1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::dimension2d&lt; f32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>textureRepeatCount</em> = <code>core::dimension2d&lt;f32&gt;(1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a Hill Plane mesh to the mesh pool. The mesh is generated on the fly and looks like a plane with some hills on it. You can specify how many hills should be on the plane and how high they should be. Also you must specify a name for the mesh because the mesh is added to the mesh pool and can be retrieved back using ISceneManager::getMesh with the name as parameter.</p>
<p>Adds a Hill Plane mesh to the mesh pool. The mesh is generated on the fly and looks like a plane with some hills on it. You can specify how many hills there should be on the plane and how high they should be. Also you must specify a name for the mesh, because the mesh is added to the mesh pool, and can be retrieved again using ISceneManager::getMesh with the name as parameter. </p>

</div>
</div>
<a class="anchor" id="ad9eb844548c09912553ef857f96380a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ILightSceneNode * irr::scene::CSceneManager::addLightSceneNode </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SColorf&#160;</td>
          <td class="paramname"><em>color</em> = <code>video::SColorf(1.0f,&#160;1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>range</em> = <code>100.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a dynamic light scene node. The light will cast dynamic light on all other scene nodes in the scene, which have the material flag video::MTF_LIGHTING turned on. (This is the default setting in most scene nodes). </p>

</div>
</div>
<a class="anchor" id="a6473a4b8ba6737268c20ba9697e1051e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMeshSceneNode * irr::scene::CSceneManager::addMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype">IMesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1.0f,&#160;1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alsoAddIfMeshPointerZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>adds a scene node for rendering a static mesh the returned pointer must not be dropped. </p>

</div>
</div>
<a class="anchor" id="aa3be92a6e7aefe7a9a6e8948232affa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMeshSceneNode * irr::scene::CSceneManager::addOctreeSceneNode </td>
          <td>(</td>
          <td class="paramtype">IAnimatedMesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>minimalPolysPerNode</em> = <code>512</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alsoAddIfMeshPointerZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a scene node for rendering using a octree to the scene graph. This a good method for rendering scenes with lots of geometry. The <a class="el" href="classirr_1_1_octree.html" title="template octree.">Octree</a> is built on the fly from the mesh, much faster then a bsp tree. </p>

</div>
</div>
<a class="anchor" id="a9d5f2d928b78ff4465b7b786f8f44797"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMeshSceneNode * irr::scene::CSceneManager::addOctreeSceneNode </td>
          <td>(</td>
          <td class="paramtype">IMesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>minimalPolysPerNode</em> = <code>128</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>alsoAddIfMeshPointerZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adss a scene node for rendering using a octree. This a good method for rendering scenes with lots of geometry. The <a class="el" href="classirr_1_1_octree.html" title="template octree.">Octree</a> is built on the fly from the mesh, much faster then a bsp tree.</p>
<p>Adds a scene node for rendering using a octree. This a good method for rendering scenes with lots of geometry. The <a class="el" href="classirr_1_1_octree.html" title="template octree.">Octree</a> is built on the fly from the mesh, much faster then a bsp tree. </p>

</div>
</div>
<a class="anchor" id="a51b8cd28f5dc81b3518f4249fa1187f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNode * irr::scene::CSceneManager::addSkyBoxSceneNode </td>
          <td>(</td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>back</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a skybox scene node. A skybox is a big cube with 6 textures on it and is drawn around the camera position. </p>

</div>
</div>
<a class="anchor" id="ab61889c3eca09fa0cb70b3c9f8a25e92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNode * irr::scene::CSceneManager::addSkyDomeSceneNode </td>
          <td>(</td>
          <td class="paramtype">video::ITexture *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>horiRes</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>vertRes</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>texturePercentage</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>spherePercentage</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>radius</em> = <code>1000.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a skydome scene node. A skydome is a large (half-) sphere with a panoramic texture on it and is drawn around the camera position. </p>

</div>
</div>
<a class="anchor" id="a54c023fa51f48e390bc36980f1d61f27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IMeshSceneNode * irr::scene::CSceneManager::addSphereSceneNode </td>
          <td>(</td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>radius</em> = <code>5.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>polyCount</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1.0f,&#160;1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a sphere scene node to the scene. </p>
<p>Adds a sphere scene node for test purposes to the scene. </p>

</div>
</div>
<a class="anchor" id="ae9de85adb1c71933ba521daebe3b12be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITextSceneNode * irr::scene::CSceneManager::addTextSceneNode </td>
          <td>(</td>
          <td class="paramtype">gui::IGUIFont *&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">video::SColor&#160;</td>
          <td class="paramname"><em>color</em> = <code>video::SColor(100,255,255,255)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a text scene node, which is able to display 2d text at a position in three dimensional space </p>

</div>
</div>
<a class="anchor" id="af7d98342a07da1787595bf4a98f20342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IVolumeLightSceneNode * irr::scene::CSceneManager::addVolumeLightSceneNode </td>
          <td>(</td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u32&#160;</td>
          <td class="paramname"><em>subdivU</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u32&#160;</td>
          <td class="paramname"><em>subdivV</em> = <code>32</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const video::SColor&#160;</td>
          <td class="paramname"><em>foot</em> = <code>video::SColor(51,&#160;0,&#160;230,&#160;180)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const video::SColor&#160;</td>
          <td class="paramname"><em>tail</em> = <code>video::SColor(0,&#160;0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1.0f,&#160;1.0f,&#160;1.0f)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>adds Volume Lighting Scene Node. the returned pointer must not be dropped. </p>

</div>
</div>
<a class="anchor" id="ae21d47b1d04e0a364799ecdfeacb1d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNodeAnimatorCollisionResponse * irr::scene::CSceneManager::createCollisionResponseAnimator </td>
          <td>(</td>
          <td class="paramtype">ITriangleSelector *&#160;</td>
          <td class="paramname"><em>world</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>sceneNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>ellipsoidRadius</em> = <code>core::vector3df(30,60,30)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>gravityPerSecond</em> = <code>core::vector3df(0,-1.0f,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>ellipsoidTranslation</em> = <code>core::vector3df(0,0,0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>slidingValue</em> = <code>0.0005f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a special scene node animator for doing automatic collision detection and response. </p>

</div>
</div>
<a class="anchor" id="abb106b4a6f0a9ff8d73be64972ffd5ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNodeAnimator * irr::scene::CSceneManager::createDeleteAnimator </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>when</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a scene node animator, which deletes the scene node after some time automaticly. </p>

</div>
</div>
<a class="anchor" id="a2d316866dc59dd0e29e185bc4e0f78fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNodeAnimator * irr::scene::CSceneManager::createFlyCircleAnimator </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>center</em> = <code>core::vector3df(0.f,&#160;0.f,&#160;0.f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>radius</em> = <code>100.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>speed</em> = <code>0.001f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code>core::vector3df(0.f,&#160;1.f,&#160;0.f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>startPosition</em> = <code>0.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">f32&#160;</td>
          <td class="paramname"><em>radiusEllipsoid</em> = <code>0.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a fly circle animator </p>
<p>creates a fly circle animator, which lets the attached scene node fly around a center.</p>
<pre class="fragment">Lets the attached scene node fly around a center.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>Center relative to node origin </td></tr>
    <tr><td class="paramname">speed,:</td><td>The orbital speed, in radians per millisecond. </td></tr>
    <tr><td class="paramname">direction,:</td><td>Specifies the upvector used for alignment of the mesh. </td></tr>
    <tr><td class="paramname">startPosition,:</td><td>The position on the circle where the animator will begin. Value is in multiples of a circle, i.e. 0.5 is half way around. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with ISceneNode::addAnimator() </dd></dl>

</div>
</div>
<a class="anchor" id="a244c8ef1830bec752f357ece18ee4173"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNodeAnimator * irr::scene::CSceneManager::createFlyStraightAnimator </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>startPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>endPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>timeForWay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pingpong</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a fly straight animator, which lets the attached scene node fly or move along a line between two points. </p>

</div>
</div>
<a class="anchor" id="a4d8020dde9333353f6bc7b6b9eb77e94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNodeAnimator * irr::scene::CSceneManager::createRotationAnimator </td>
          <td>(</td>
          <td class="paramtype">const core::vector3df &amp;&#160;</td>
          <td class="paramname"><em>rotationPerSecond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a rotation animator, which rotates the attached scene node around itself. </p>
<p>creates a rotation animator, which rotates the attached scene node around itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationPerSecond,:</td><td>Specifies the speed of the animation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The animator. Attach it to a scene node with ISceneNode::addAnimator() and the animator will animate it. </dd></dl>

</div>
</div>
<a class="anchor" id="a42dea70677b1745e23afe10a20bf00db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITriangleSelector * irr::scene::CSceneManager::createTerrainTriangleSelector </td>
          <td>(</td>
          <td class="paramtype">ITerrainSceneNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>LOD</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a triangle selector which can select triangles from a terrain scene node. </p>
<p>Creates a triangle selector which can select triangles from a terrain scene node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>Pointer to the created terrain scene node </td></tr>
    <tr><td class="paramname"></td><td>Level of detail, 0 for highest detail. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14319a725b000a5c19b3e07e19eb2898"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNodeAnimator * irr::scene::CSceneManager::createTextureAnimator </td>
          <td>(</td>
          <td class="paramtype">const core::array&lt; video::ITexture * &gt; &amp;&#160;</td>
          <td class="paramname"><em>textures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>timePerFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a texture animator, which switches the textures of the target scene node based on a list of textures. </p>

</div>
</div>
<a class="anchor" id="a90637f2287c1e4d6167b6d638a17d5ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITriangleSelector * irr::scene::CSceneManager::createTriangleSelector </td>
          <td>(</td>
          <td class="paramtype">IAnimatedMeshSceneNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a simple ITriangleSelector, based on an animated mesh scene node. Details of the mesh associated with the node will be extracted internally. Call ITriangleSelector::update() to have the triangle selector updated based on the current frame of the animated mesh scene node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td>The animated mesh scene node from which to build the selector</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a simple and updatable ITriangleSelector, based on a the mesh owned by an animated scene node </p>

</div>
</div>
<a class="anchor" id="af861474ffb96b9d4d2d9a6d6303cdb6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CSceneManager::drawAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>draws all scene nodes </p>
<p>This method is called just before the rendering process of the whole scene. draws all scene nodes </p>
<p>First Scene Node for prerendering should be the active camera consistent Camera is needed for culling</p>

</div>
</div>
<a class="anchor" id="a5b85191fa5bd908a1c2474bf440f49f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ICameraSceneNode * irr::scene::CSceneManager::getActiveCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current active camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The active camera is returned. Note that this can be NULL, if there was no camera created yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a90a12f000d4caf2ca512a73a6bd47d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">io::IFileSystem * irr::scene::CSceneManager::getFileSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the filesystem </p>
<p>Get the active FileSystem.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the FileSystem This pointer should not be dropped. See IReferenceCounted::drop() for more information. </dd></dl>

</div>
</div>
<a class="anchor" id="a279172e9c8035c9130525d1cf616cd6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gui::IGUIEnvironment * irr::scene::CSceneManager::getGUIEnvironment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the gui environment </p>
<p>returns the GUI Environment </p>

</div>
</div>
<a class="anchor" id="acb8872a7d44b695f0115afc518d1778d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ISceneNode * irr::scene::CSceneManager::getRootSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the root scene node. This is the scene node wich is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It is not rendered and cannot be removed from the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root scene node.</dd></dl>
<p>Returns the root scene node. This is the scene node wich is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It is not rendered and cannot be removed from the scene. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the root scene node. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a26bb986e97ceef455243546d1630c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">u32 irr::scene::CSceneManager::getSceneLoaderCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of scene loaders supported by Irrlicht at this time. </p>
<p>Returns the number of scene loaders. </p>

</div>
</div>
<a class="anchor" id="a03b1765239c02e9b934624a8ec30214c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::CSceneManager::loadScene </td>
          <td>(</td>
          <td class="paramtype">const io::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneUserDataSerializer *&#160;</td>
          <td class="paramname"><em>userDataSerializer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>rootNode</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a scene. Note that the current scene is not cleared before. </p>
<p>Loads a scene. </p>

</div>
</div>
<a class="anchor" id="a1702d5a194a210f7c36e808593e43ceb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::CSceneManager::postEventFromUser </td>
          <td>(</td>
          <td class="paramtype">const SEvent &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Posts an input event to the environment. Usually you do not have to use this method, it is used by the internal engine. </p>

</div>
</div>
<a class="anchor" id="a2e04c241d92ec1efc20386b47f77f5cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CSceneManager::registerSceneNodeFactory </td>
          <td>(</td>
          <td class="paramtype">ISceneNodeFactory *&#160;</td>
          <td class="paramname"><em>factoryToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node factory to the scene manager. </p>
<pre class="fragment">Use this to extend the scene manager with new scene node types which it should be
</pre><p> able to create automaticly, for example when loading data from xml files. </p>

</div>
</div>
<a class="anchor" id="a17da0640769c7dca94535d8d4a39d5e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::CSceneManager::saveScene </td>
          <td>(</td>
          <td class="paramtype">const io::path &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneUserDataSerializer *&#160;</td>
          <td class="paramname"><em>userDataSerializer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISceneNode *&#160;</td>
          <td class="paramname"><em>node</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the current scene into a file. </p>
<p>Saves the current scene into a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename,:</td><td>Name of the file . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a28d4630075ef900d9cc0eb40ba9ba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CSceneManager::setActiveCamera </td>
          <td>(</td>
          <td class="paramtype">ICameraSceneNode *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the active camera. The previous active camera will be deactivated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera,:</td><td>The new camera which should be active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Ben/Documents/Visual Studio 2010/Projects/PSI/source/Irrlicht/<a class="el" href="_c_scene_manager_8h_source.html">CSceneManager.h</a></li>
<li>C:/Users/Ben/Documents/Visual Studio 2010/Projects/PSI/source/Irrlicht/CSceneManager.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>irr</b></li><li class="navelem"><b>scene</b></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1_c_scene_manager.html">CSceneManager</a></li>
    <li class="footer">Generated on Wed Mar 20 2013 15:24:57 for Irrlicht by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
